//Every plugin has several information like configuration, their tasks, report generation, integration with other tasks, configuring options etc.
//So applying plugin is like extending features

apply(from: "$project.rootDir/scripts/common.gradle") //for appModuleSourceSets
apply(plugin: "checkstyle") //applying plugin is like importing classes

// apply plugin: "checkstyle" or apply(plugin: "checkstyle") same thing.
// First is more common in Groovy, where checkstyle string is a value of plugin id
// second is using a named parameter syntax aka method call with a map argument


//only Project Settings, Plugins or build scripts file scripts contain plugins {} blocks
/*plugins {
    id "checkstyle"
}*/

/*plugins {
    checkstyle //this is shorthand provided by the Plugins DSL.  Simply enter the value of Plugins id
}*/


//checkstyle plugin configuration block. The keyword checkstyle is provided by checkstyle plugin
checkstyle {
    toolVersion = "10.11.0"

    configFile = file("${rootDir}/config/checkstyle/checkstyle.xml")

    configProperties['ignoreFailures'] = false
    configProperties['showViolations'] = true
    configProperties['lineWidth'] = 120
    configProperties['checkstyleSuppressions'] = project.file("${rootDir}/config/checkstyle/suppressions.xml")
    configProperties['checkstyleSuppressionConfigDir'] = project.file("${rootDir}/config/checkstyle")
}

//create a new configuration named checkstyle within the Gradle build script.
configurations {
    //basically we now get checkstyle plugin configuration block into our gradle configuration block
    checkstyle //creates a configuration name with checkstyle that has its own lifecycle
}

//tasks = Project.getTask(). tasks is a TaskContainer. TaskContainer holds Task Type
//tasks are then run so, we can define how much heap memory we should allocate, and after tasks complete where to generate reports etc.
tasks.withType(Checkstyle) {
    minHeapSize = "1000m"
    maxHeapSize = "4g"
    reports {
        xml.required = true
        html.required = true
        html.stylesheet = resources.text.fromFile("${rootDir}/config/checkstyle/xsl/checkstyle-simple.xsl")
    }
}

//you can run task from here just to check

appModuleSourceSets.each { sourceSetName ->
    tasks.create("checkstyle${sourceSetName.capitalize()}", Checkstyle) {
        group = 'verification'
        description = "Runs check task for ${sourceSetName.capitalize()} source set"

        source = fileTree(dir: "src/${sourceSetName}", includes: ["**/*.java", "**/*.kt"], excludes: ["**/R.java", "**/BuildConfig.java", "**/gen/**"])
        // include("**/*.java", "**/*.kt")
        // exclude("**/R.java", "**/BuildConfig.java", "**/gen/**")
        classpath = files()
    }
}

//how gradle runs tasks?
/*In Gradle, tasks are executed as part of the build process according to their dependencies and the order defined in the build script. Gradle determines the task execution order based on a directed acyclic graph (DAG) that represents the task relationships.

When you invoke a Gradle command, such as gradle build, Gradle performs the following steps to run tasks:

        Initialization: Gradle initializes the project by evaluating the build script files (e.g., build.gradle, settings.gradle). It configures the project structure, applies plugins, sets up repositories, and defines tasks.

Task Configuration: Gradle determines the task execution order by evaluating the task dependencies and relationships defined in the build script. It constructs a DAG that represents the tasks and their dependencies. Each task has a set of inputs, outputs, and actions defined.

        Task Execution: Gradle starts executing the tasks based on the DAG. It checks if a task's inputs are up-to-date by comparing them with the outputs of its dependencies. If the inputs are up-to-date, Gradle skips the task. Otherwise, Gradle executes the task's actions.

Incremental Build: Gradle performs incremental builds to optimize the build process. It only executes tasks that are affected by changes since the last build. This helps speed up the build by skipping unnecessary tasks.

        Task Skipped and Up-to-date Checking: Gradle skips tasks that have already been executed and are up-to-date. If a task's inputs and outputs have not changed since the previous execution, Gradle considers the task up-to-date and skips its execution. This reduces redundant work in subsequent builds.

Dependency Resolution: Gradle resolves and downloads dependencies required by the build, such as external libraries or plugins, based on the declared dependencies in the build script.

        Reporting: Gradle generates reports and logs to provide information about the build process, including task execution results, test reports, code coverage reports, and more.

        Gradle's build process is highly configurable and can be extended with custom tasks, plugins, and build logic. You can define dependencies between tasks, specify task inputs and outputs, control task execution order, and incorporate complex build workflows using Gradle's powerful features and APIs.

Overall, Gradle provides a flexible and efficient way to run tasks by analyzing task dependencies, checking inputs and outputs for up-to-date status, and executing only the necessary tasks to build your project.
        */

