project.afterEvaluate { project ->
    setupAndroidReporting()
}

def setupAndroidReporting() {
    tasks.withType(Test) {
        // Whether or not classes without source location should be instrumented
        jacoco.includeNoLocationClasses = true
        jacoco.excludes = ['jdk.internal.*']
    }

    // Grab all build types and product flavors
    def buildTypes = android.buildTypes.collect { type ->
        type.name
    }
    def productFlavors = android.productFlavors.collect { flavor ->
        flavor.name
    }

    // When no product flavors defined, use empty
    if (!productFlavors) productFlavors.add('')
    productFlavors.each { productFlavorName ->
        buildTypes.each { buildTypeName ->
            def sourceName, sourcePath
            if (!productFlavorName) {
                sourceName = "${buildTypeName}"
                sourcePath = "${buildTypeName}"
            } else {
                def newProductFlavorName = "${productFlavorName}Stage"
                sourceName = "${newProductFlavorName}${buildTypeName.capitalize()}"
                sourcePath = "${newProductFlavorName}/${buildTypeName}"
            }
            def testTaskName = "test${sourceName.capitalize()}UnitTest"
            System.out.println("Task -> $testTaskName")

            //if there are testStageStageReleaseUnitTest like task where there are two "Stage"
            def substring = "Stage"
            def pattern = /${substring}${substring}/
            if (testTaskName.find(pattern)) {
                //nothing to do
            } else {
                // Create coverage task of form 'testFlavorTypeCoverage' depending on 'testFlavorTypeUnitTest'
                task "${testTaskName}Coverage"(type: JacocoReport, dependsOn: "$testTaskName") {
                    group = "jacoco-unittest-reporting"
                    description = "Generate Jacoco coverage reports on the ${sourceName.capitalize()} build."

                    def fileFilter = [
                            // data binding
                            'android/databinding/**/*.class',
                            '**/android/databinding/*Binding.class',
                            '**/android/databinding/*',
                            '**/androidx/databinding/*',
                            '**/BR.*',
                            // android
                            '**/R.class',
                            '**/R$*.class',
                            '**/BuildConfig.*',
                            '**/Manifest*.*',
                            '**/*Test*.*',
                            'android/**/*.*',
                            // kotlin
                            '**/*MapperImpl*.*',
                            '**/*$ViewInjector*.*',
                            '**/*$ViewBinder*.*',
                            '**/BuildConfig.*',
                            '**/*Component*.*',
                            '**/*BR*.*',
                            '**/Manifest*.*',
                            '**/*$Lambda$*.*',
                            '**/*Companion*.*',
                            '**/*Module*.*',
                            '**/*Dagger*.*',
                            '**/*Hilt*.*',
                            '**/*MembersInjector*.*',
                            '**/*_MembersInjector.class',
                            '**/*_Factory*.*',
                            '**/*_Provide*Factory*.*',
                            '**/*Extensions*.*',
                            // sealed and data classes
                            '**/*$Result.*',
                            '**/*$Result$*.*',
                            // adapters generated by moshi
                            '**/*JsonAdapter.*',
                    ]

                    def javaTree = fileTree(dir: "${project.buildDir}/intermediates/javac/$sourceName/classes", excludes: fileFilter)
                    def kotlinTree = fileTree(dir: "${project.buildDir}/tmp/kotlin-classes/$sourceName", excludes: fileFilter)
                    classDirectories.from = files([javaTree], [kotlinTree])
                    executionData.from = files("${project.buildDir}/outputs/unit_test_code_coverage/${testTaskName}.exec")
                    def coverageSourceDirs = ["src/main/java",
                                              "src/$productFlavorName/java",
                                              "src/$buildTypeName/java"]

                    sourceDirectories.setFrom(files(coverageSourceDirs))
                    additionalSourceDirs.setFrom(files(coverageSourceDirs))

                    reports {
                        csv {
                            required = true
                            enabled true
                            csv.destination file("${project.rootDir}/xml-coverage-report/jacoco.csv")
                        }
                        xml {
                            required = true
                            enabled true
                            xml.destination file("${project.rootDir}/xml-coverage-report/jacoco.xml")
                        }
                        html {
                            required = true
                            enabled true
                            html.destination file("${project.rootDir}/xml-coverage-report/jacoco.html")
                        }
                    }
                }
            }
        }
    }
}
